/*
 * @Author: yangxcc
 * @version: 1.0
 * @Date: 2023-06-11 14:01:13
 * @LastEditTime: 2023-06-11 14:24:34
 */
package hydro;

import java.util.Scanner;

/**
 * 问题来源：https://codefun2000.com/p/P1166
 * 
 * 问题描述：塔子哥的班级坐落在教学楼的正中央，塔子哥班级的座位排成了 n 行(行从1到n编号)，共有m个大列(大列从1到m编号)，
 * 每个大列中有 a 个小列(小列从1到a编号)，大列与大列之间有一个过道。
 * 班主任规定每周进行一次座位调整，为了使同学们有机会结交不同的同学，每周的座位调整遵循特定的规则，具体规则如下：
 * 1. 首先所有同学都换到后一行，最后一行的同学换到第一行。即对于坐在第 i<n 行的同学，新位置在第 i+1 行，如果i=n ，那么新位置在第一行；
 * 2. 然后所有同学都移动到自己右边的那个大列的相同小列上，在最右大列的同学移动到最左大列。即对于坐在第j<m大列的同学，新位置在第 j+1 大列，如果
 * j=m ，那么新位置在第一大列；对于坐在第 k 小列的同学，新位置仍然在第 k 小列。
 * 
 * 然而，学校最近购进了新型的学生桌椅，这些桌椅可以调节高度，有些同学把桌子的高度调高了，而有些同学则没有。
 * 于是，在座位调整后，如果一位调整过桌子高度的同学坐到了没有调整过桌子高度的同学的位置，他会调整新位置的桌子到他想要的高度；
 * 同样地，如果一位没有调整过桌子高度的同学坐到了调整过桌子高度同学的位置，他也会调整新位置的桌子高度，使其恢复原高度。
 * 现在塔子哥的班级要进行换座位了，给出换座位前班级所有桌子的情况，塔子哥想知道，
 * 换一次位置后，有多少同学需要重新调整桌子高度。
 * 
 * 输入描述：输入第一行包含三个数 n ， m ， a ，意义如题目所示。接下来 n 行，每行 m 个长度为 a 的 01 字符串，
 * 表示目前塔子哥班上的桌子情况。其中 0 表示这个位置未调节桌子高度，1 表示已调节桌子高度。
 * 对于全部数据，1≤n,m≤200,n×m≥2,1≤a≤5
 * 
 * 输出描述：输出一行一个整数，表示换座位后有多少同学需要重新调整桌子高度。
 * 
 * 这道题其实就是模拟，比较换位前后的值
 */
public class Problem51 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), m = in.nextInt(), a = in.nextInt();
        String[][] grid = new String[n][m];
        in.nextLine();
        for (int i = 0; i < n; i++) {
            grid[i] = in.nextLine().split(" ");
        }

        // 移动后的座位
        /**
         * 01 10 00
         * 10 00 11
         * 01 00 00
         * 
         * 01 00 00
         * 01 10 00
         * 10 00 11
         * 
         * 00 01 00
         * 00 01 10
         * 11 10 00
         */
        String[][] move = new String[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == n - 1 && j == m - 1) {
                    move[0][0] = grid[i][j];
                } else if (j == m - 1) {
                    // 最后一列
                    move[i + 1][0] = grid[i][j];
                } else if (i == n - 1) {
                    // 最后一行
                    move[0][j + 1] = grid[i][j];
                } else {
                    move[i + 1][j + 1] = grid[i][j];
                }

            }
        }

        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < a; k++) {
                    if (grid[i][j].charAt(k) != move[i][j].charAt(k)) {
                        count++;
                    }
                }
            }
        }

        System.out.println(count);
        in.close();
    }
}
